// ============================================================
// UI - Upload, header controls, modals, search
// ============================================================

import { SpoilerLogParser, ItemLogParser } from './parser.js';
import * as State from './state.js';
import * as Exploration from './exploration.js';
import * as Toast from './toast.js';

// ============================================================
// DOM ELEMENTS
// ============================================================

const uploadScreen = document.getElementById('upload-screen');
const mainUI = document.getElementById('main-ui');
const dropZone = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
const errorMessage = document.getElementById('error-message');
const newFileBtn = document.getElementById('new-file-btn');
const searchInput = document.getElementById('search');
const searchDropdown = document.getElementById('search-dropdown');

// ============================================================
// FILE UPLOAD
// ============================================================

function showError(msg) {
    errorMessage.innerHTML = msg;
}

function clearError() {
    errorMessage.innerHTML = '';
}

// Process spoiler log text (common logic for files and demo)
function processSpoilerLogText(text) {
    // Detect spoiler log type
    const hasFogPatterns = text.includes('Preexisting:');
    const hasScaling = text.includes('scaling:');
    
    if (!hasFogPatterns && !hasScaling) {
        if (text.includes('-- Item preset')) {
            throw new Error('This appears to be an <strong>Item Randomizer</strong> spoiler log, not a Fog Randomizer log.<br><br>Please load a spoiler log from the <strong>Fog Gate Randomizer</strong> mod.');
        }
        if (text.includes('-- Enemy preset')) {
            throw new Error('This appears to be an <strong>Enemy Randomizer</strong> spoiler log, not a Fog Randomizer log.<br><br>Please load a spoiler log from the <strong>Fog Gate Randomizer</strong> mod.');
        }
        throw new Error('This does not appear to be a valid Fog Randomizer spoiler log.<br><br>Make sure you\'re loading the spoiler log generated by the <strong>Fog Gate Randomizer</strong> mod.');
    }
    
    const graphData = SpoilerLogParser.parse(text);
    
    if (graphData.nodes.length === 0) {
        throw new Error('No areas found in the log file.');
    }
    
    // Show main UI
    uploadScreen.classList.add('hidden');
    mainUI.classList.add('visible');
    
    // Reset search and item log
    searchInput.value = '';
    State.setItemLogData(null);
    updateItemLogButton(false);
    
    // Compute one-way links before storing
    Exploration.computeOneWayLinks(graphData.links);
    
    // Set seed BEFORE render so exploration state can be loaded
    const newSeed = graphData.metadata?.seed || 'unknown';
    State.setSeed(newSeed);
    
    // Load exploration state BEFORE render (if saved), or initialize
    if (State.isExplorationMode()) {
        const existingSave = State.loadExplorationFromStorage(newSeed);
        if (existingSave) {
            State.setExplorationState(existingSave);
            // Don't show banner - progression is already loaded
        } else {
            Exploration.initExplorationState();
        }
    }
    
    // Store graph data and trigger render
    State.setGraphData(graphData);
    State.emit('graphNeedsRender', { preservePositions: false });

    // Update UI controls based on current mode
    updateModeButtons();
}

function handleFile(file) {
    clearError();
    
    if (!file) {
        showError('No file selected');
        return;
    }
    
    const reader = new FileReader();
    
    reader.onload = (e) => {
        try {
            processSpoilerLogText(e.target.result);
        } catch (err) {
            console.error(err);
            showError(err.message || 'Error parsing the log file: ' + err);
        }
    };
    
    reader.onerror = () => {
        showError('Error reading the file.');
    };
    
    reader.readAsText(file);
}

function loadDemoData() {
    clearError();
    
    fetch('data/demo_log.txt')
        .then(response => {
            if (!response.ok) {
                throw new Error('Demo file not found');
            }
            return response.text();
        })
        .then(text => {
            processSpoilerLogText(text);
        })
        .catch(err => {
            console.error(err);
            showError('Error loading demo: ' + err.message);
        });
}

// ============================================================
// ITEM LOG
// ============================================================

const addItemLogBtn = document.getElementById('add-item-log-btn');
const itemLogInput = document.createElement('input');
itemLogInput.type = 'file';
itemLogInput.accept = '.txt,.log';
itemLogInput.classList.add('hidden');
document.body.appendChild(itemLogInput);

function updateItemLogButton(loaded) {
    if (loaded) {
        addItemLogBtn.classList.add('loaded');
        addItemLogBtn.textContent = 'âœ“ Item Log Loaded';
    } else {
        addItemLogBtn.classList.remove('loaded');
        addItemLogBtn.textContent = 'Add Item Log';
    }
}

function handleItemLogFile(file) {
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (evt) => {
        try {
            const text = evt.target.result;
            
            if (!text.includes('-- Hints for key items:')) {
                Toast.error('Invalid Item Randomizer log. Look for a file containing "-- Hints for key items:"');
                return;
            }
            
            const parsed = ItemLogParser.parse(text);
            State.setItemLogData(parsed);
            updateItemLogButton(true);
            
            // Re-render graph to apply item info
            State.emit('graphNeedsRender', { preservePositions: true });
            
            console.log('Item log loaded:', parsed.keyItems.size, 'zones with key items');
        } catch (err) {
            console.error(err);
            Toast.error('Error parsing the item log: ' + err.message);
        }
    };
    
    reader.readAsText(file);
    itemLogInput.value = '';
}

// ============================================================
// SEARCH
// ============================================================

function handleSearch(query) {
    if (!query) {
        searchDropdown.classList.remove('visible');
        searchDropdown.innerHTML = '';
        State.emit('searchCleared');
        return;
    }
    
    const graphData = State.getGraphData();
    if (!graphData) return;
    
    // Find matching nodes
    const matching = graphData.nodes.filter(n => 
        n.id.toLowerCase().includes(query.toLowerCase())
    );
    
    State.emit('searchMatched', { matchingIds: new Set(matching.map(n => n.id)) });
    
    // Show dropdown with undiscovered matches in exploration mode
    if (State.isExplorationMode()) {
        const explorationState = State.getExplorationState();
        const undiscoveredMatches = matching.filter(n => 
            !explorationState.discovered.has(n.id)
        );
        
        if (undiscoveredMatches.length > 0) {
            let html = '';
            undiscoveredMatches.slice(0, 8).forEach(n => {
                html += `
                    <div class="search-result">
                        <div>
                            <span class="search-result-name">${n.id}</span>
                            <span class="search-result-status">(not discovered)</span>
                        </div>
                        <button class="search-result-btn" data-node-id="${n.id}">ðŸŽ¯ I've reached</button>
                    </div>
                `;
            });
            if (undiscoveredMatches.length > 8) {
                html += `<div class="search-result"><span class="search-result-status">... and ${undiscoveredMatches.length - 8} more</span></div>`;
            }
            searchDropdown.innerHTML = html;
            searchDropdown.classList.add('visible');
            
            // Add click handlers
            searchDropdown.querySelectorAll('.search-result-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const nodeId = this.getAttribute('data-node-id');
                    Exploration.discoverPathTo(nodeId);
                    searchInput.value = '';
                    searchDropdown.classList.remove('visible');
                    searchDropdown.innerHTML = '';
                    State.emit('searchCleared');
                });
            });
        } else {
            searchDropdown.classList.remove('visible');
            searchDropdown.innerHTML = '';
        }
    }
}

// ============================================================
// MODE SWITCHING
// ============================================================

function updateModeButtons() {
    const modeSpoilerBtn = document.getElementById('mode-spoiler');
    const modeExplorerBtn = document.getElementById('mode-explorer');
    const explorerControls = document.getElementById('explorer-controls');
    const frontierCheckbox = document.getElementById('show-frontier-checkbox');

    const explorationMode = State.isExplorationMode();

    if (explorationMode) {
        modeExplorerBtn.classList.add('active');
        modeSpoilerBtn.classList.remove('active');
        explorerControls.classList.remove('hidden');
    } else {
        modeSpoilerBtn.classList.add('active');
        modeExplorerBtn.classList.remove('active');
        explorerControls.classList.add('hidden');
    }

    // Reset frontier checkbox state
    if (frontierCheckbox) {
        frontierCheckbox.checked = false;
    }
    State.setFrontierHighlightActive(false);
}

function switchToSpoilerMode() {
    if (!State.isExplorationMode()) return;
    
    State.setExplorationMode(false);
    updateModeButtons();
    
    State.emit('graphNeedsRender', { preservePositions: true });
}

function switchToExplorerMode() {
    if (State.isExplorationMode()) return;
    
    State.setExplorationMode(true);
    updateModeButtons();
    
    // Check for existing save
    const seed = State.getSeed();
    if (seed) {
        const existingSave = State.loadExplorationFromStorage(seed);
        if (existingSave) {
            State.setExplorationState(existingSave);
            // Progression loaded automatically
        } else {
            Exploration.initExplorationState();
        }
    }
    
    State.emit('graphNeedsRender', { preservePositions: true });
}

// ============================================================
// FRONTIER HIGHLIGHT
// ============================================================

export function highlightFrontier() {
    const explorationState = State.getExplorationState();
    const graphData = State.getGraphData();
    if (!explorationState || !graphData) return;

    const svg = d3.select("svg");
    const nodes = svg.selectAll(".node");
    const links = svg.selectAll(".link");

    // Find access nodes (discovered nodes that have undiscovered neighbors)
    const accessNodes = new Set();

    graphData.links.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;

        const sourceDiscovered = explorationState.discovered.has(sourceId);
        const targetDiscovered = explorationState.discovered.has(targetId);

        if (sourceDiscovered && !targetDiscovered) {
            accessNodes.add(sourceId);
        } else if (!sourceDiscovered && targetDiscovered && !link.oneWay) {
            accessNodes.add(targetId);
        }
    });

    // Apply highlights - placeholder nodes (isPlaceholder) are frontier nodes
    nodes.classed("frontier-highlight", d => d.isPlaceholder === true)
         .classed("access-highlight", d => accessNodes.has(d.id))
         .classed("dimmed", d => !d.isPlaceholder && !accessNodes.has(d.id));

    // Links to placeholder nodes are frontier links
    links.classed("frontier-highlight", l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        // A link is frontier if it connects to a placeholder (starts with ???_)
        return sourceId.startsWith('???_') || targetId.startsWith('???_');
    })
    .classed("dimmed", l => {
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;
        // Dim links that don't connect to placeholders and don't connect access nodes
        const isToPlaceholder = sourceId.startsWith('???_') || targetId.startsWith('???_');
        const connectsAccessNode = accessNodes.has(sourceId) || accessNodes.has(targetId);
        return !isToPlaceholder && !connectsAccessNode;
    });
}

export function clearFrontierHighlight() {
    const svg = d3.select("svg");
    svg.selectAll(".node")
        .classed("frontier-highlight", false)
        .classed("access-highlight", false)
        .classed("dimmed", false)
        .classed("highlighted", false);
    svg.selectAll(".link")
        .classed("frontier-highlight", false)
        .classed("dimmed", false)
        .classed("highlighted", false);

    // Restore selection highlight if a node is selected
    State.emit('restoreSelectionHighlight');
}

function onFrontierCheckboxChange(checked) {
    if (!State.isExplorationMode() || !State.getGraphData()) return;

    State.setFrontierHighlightActive(checked);

    if (checked) {
        highlightFrontier();
    } else {
        clearFrontierHighlight();
    }
}

// ============================================================
// EVENT LISTENERS SETUP
// ============================================================

export function initUI() {
    // File upload
    dropZone.addEventListener('click', () => fileInput.click());
    
    fileInput.addEventListener('change', (e) => {
        handleFile(e.target.files[0]);
    });
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
    });
    
    dropZone.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        handleFile(e.dataTransfer.files[0]);
    });
    
    // New file button
    newFileBtn.addEventListener('click', () => {
        mainUI.classList.remove('visible');
        uploadScreen.classList.remove('hidden');
        fileInput.value = '';
        clearError();
        State.setItemLogData(null);
        
        const sim = State.getSimulation();
        if (sim) sim.stop();
    });
    
    // Demo button
    const demoBtn = document.getElementById('demo-btn');
    if (demoBtn) {
        demoBtn.addEventListener('click', loadDemoData);
    }
    
    // Item log
    addItemLogBtn.addEventListener('click', () => itemLogInput.click());
    itemLogInput.addEventListener('change', (e) => handleItemLogFile(e.target.files[0]));
    
    // Search
    searchInput.addEventListener('input', (e) => handleSearch(e.target.value));
    
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#search-container')) {
            searchDropdown.classList.remove('visible');
        }
    });
    
    // Mode buttons
    const modeSpoilerBtn = document.getElementById('mode-spoiler');
    const modeExplorerBtn = document.getElementById('mode-explorer');
    
    modeSpoilerBtn.addEventListener('click', switchToSpoilerMode);
    modeExplorerBtn.addEventListener('click', switchToExplorerMode);
    
    // Reset button
    const resetBtn = document.getElementById('reset-exploration-btn');
    resetBtn.addEventListener('click', () => {
        if (confirm('Reset your exploration progress? All discovered areas and tags will be lost.')) {
            Exploration.resetExplorationState();
        }
    });
    
    // Frontier checkbox
    const frontierCheckbox = document.getElementById('show-frontier-checkbox');
    if (frontierCheckbox) {
        frontierCheckbox.addEventListener('change', () => {
            onFrontierCheckboxChange(frontierCheckbox.checked);
        });
    }
    
    // Path from start checkbox
    const pathCheckbox = document.getElementById('show-path-from-start');
    if (pathCheckbox) {
        pathCheckbox.addEventListener('change', () => {
            State.emit('pathFromStartChanged', pathCheckbox.checked);
        });
    }
    
    // Window resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
        if (State.getGraphData() && mainUI.classList.contains('visible')) {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                State.saveAllNodePositions();
                State.emit('graphNeedsRender', { preservePositions: true });
            }, 150);
        }
    });
    
    // Subscribe to state events
    State.subscribe('explorationReset', () => {
        State.emit('graphNeedsRender', { preservePositions: false });
    });
    
    // Update UI based on frontier state changes
    // Only recalculate frontier if we're the host (not viewer)
    State.subscribe('frontierHighlightChanged', (active) => {
        const frontierCheckbox = document.getElementById('show-frontier-checkbox');
        if (frontierCheckbox) {
            frontierCheckbox.checked = active;
        }

        // Only apply highlight changes if we're the host or not connected
        // Viewers receive visual classes directly from host via applyVisualClasses()
        if (!State.isSyncConnected() || State.isStreamerHost()) {
            if (active) {
                highlightFrontier();
            } else {
                clearFrontierHighlight();
            }
        }
    });
}

// ============================================================
// EXPORTS
// ============================================================

export {
    showError,
    clearError,
    handleFile,
    updateModeButtons
};
